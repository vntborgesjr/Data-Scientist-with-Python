for sample in range(50):
# Generate bootstrap sample: bs_sample
bs_sample = np.random.choice(rainfall, size = len(rainfall))
# Compute and plot ECDF from bootstrap sample
x, y = ecdf(bs_sample)
_ = plt.plot(x, y, marker = '.', linestyle = 'none',
color = 'red')
# Compute and plot ECDF from original data
x, y = ecdf(rainfall)
_ = plt.plot(x, y, marker = '.', alpha = 0.1)
# Make margins and label axes
plt.margins(0.02)
_ = plt.xlabel('yearly rainfall (mm)')
_ = plt.ylabel('ECDF')
# Show the plot
plt.show()
plt.clf()
def bootstrap_replicate_1d(data, func):
"""Generate bootstrap replicate of 1d data"""
bs_sample = np.random.choice(data, len(data))
return func(bs_sample)
quit
def bootstrap_replicate_1d(data, func):
"""Generate bootstrap replicate of 1d data"""
bs_sample = np.random.choice(data, len(data))
return func(bs_sample)
bootstrap_replicate_1d(michelson_speed_of_light, np.mean)
bootstrap_replicate_1d(michelson_speed_of_light, np.mean)
bootstrap_replicate_1d(michelson_speed_of_light, np.mean)
bs_replicates = np.empty(10000)
for i in range(10000):
bs_replicates[i] = bootstrap_replicate_1d(michelson_speed_of_light,np.mean)
bootstrap_replicate_1d(michelson_speed_of_light, np.mean)
bs_replicates = np.empty(10000)
for i in range(10000):
bs_replicates[i] = bootstrap_replicate_1d(michelson_speed_of_light,np.mean)
quit
_ = plt.hist(bs_replicates, bin = 30, density = True)
_ = plt.xlabel('mean speed of light (km/s)')
_ = plt.ylabel('PDF')
plt.show()
plt.clf()
plt.clf()
_ = plt.hist(bs_replicates, bin = 30, density = True)
_ = plt.xlabel('mean speed of light (km/s)')
_ = plt.ylabel('PDF')
plt.show()
plt.clf()
michelson_speed_of_light
bs_replicates = np.empty(10000)
for i in range(10000):
bs_replicates[i] = bootstrap_replicate_1d(michelson_speed_of_light, np.mean)
quit
_ = plt.hist(bs_replicates, bin = 30, density = True)
_ = plt.xlabel('mean speed of light (km/s)')
_ = plt.ylabel('PDF')
plt.show()
plt.clf()
bs_replicates
bs_replicates
_ = plt.hist(bs_replicates, bin = 30, density = True)
_ = plt.xlabel('mean speed of light (km/s)')
_ = plt.ylabel('PDF')
plt.show()
plt.clf()
_ = plt.hist(bs_replicates, bin = 50, density = True)
_ = plt.xlabel('mean speed of light (km/s)')
_ = plt.ylabel('PDF')
plt.show()
plt.clf()
_ = plt.hist(bs_replicates, bin = 80, density = True)
_ = plt.xlabel('mean speed of light (km/s)')
_ = plt.ylabel('PDF')
plt.show()
plt.clf()
_ = plt.hist(bs_replicates, bins = 30, density = True)
_ = plt.xlabel('mean speed of light (km/s)')
_ = plt.ylabel('PDF')
plt.show()
plt.clf()
conf_int = np.percentile(bs_replicates, [2.5, 97.5])
print(conf_int)
conf_int = np.percentile(bs_replicates, [2.5, 97.5])
print(conf_int)
def draw_bs_reps(data, func, size = 1):
"""Draw bootstrap replicates."""
# Initialize array of replicates: bs_replicates
bs_replicates = np.empty(size)
# Generate replicates
for i in range(size):
bs_replicates[i] = bootstrap_replicate_1d(data, func)
return bs_replicates
quit
# Take 10,000 bootstrap replicates of the mean: bs_replicates
bs_replicates = draw_bs_reps(rainfall, np.mean, 10000)
# Compute and print SEM
sem = np.std(rainfall) / np.sqrt(len(rainfall))
print(sem)
# Compute and print standard deviation of bootstrap replicates
bs_std = np.std(bs_replicates)
print(bs_std)
# Make a histogram of the results
_ = plt.hist(bs_replicates, bins = 50, density = True)
_ = plt.xlabel('mean annual rainfall (mm)')
_ = plt.ylabel('PDF')
# Show the plot
plt.show()
plt.clf()
conf_int = np.percentile(bs_replicates, [2.5, 97.5])
print(conf_int)
len(rainfall)
# Generate 10,000 bootstrap replicates of the variance: bs_replicates
bs_replicates = draw_bs_reps(rainfall, np.var, 10000)
# Put the variance in units of square centimeters
bs_replicates/100
# Make a histogram of the results
_ = plt.hist(bs_replicates, bins = 50, density = True)
_ = plt.xlabel('variance of annual rainfall (sq. cm)')
_ = plt.ylabel('PDF')
# Show the plot
plt.show()
plt.clf()
bs_replicates/100
# Generate 10,000 bootstrap replicates of the variance: bs_replicates
bs_replicates = draw_bs_reps(rainfall, np.var, 10000)
# Put the variance in units of square centimeters
bs_replicates = bs_replicates/100
# Make a histogram of the results
_ = plt.hist(bs_replicates, bins = 50, density = True)
_ = plt.xlabel('variance of annual rainfall (sq. cm)')
_ = plt.ylabel('PDF')
# Show the plot
plt.show()
plt.clf()
420,   87,   71,  814,  603, 1349,  162, 1027,  783,  326,  101,
nohitter_times = np.array([ 843, 1613, 1101,  215,  684,  814,  278,  324,  161,  219,  545,
715,  966,  624,   29,  450,  107,   20,   91, 1325,  124, 1468,
104, 1309,  429,   62, 1878, 1104,  123,  251,   93,  188,  983,
166,   96,  702,   23,  524,   26,  299,   59,   39,   12,    2,
1084, 2900, 2432,  750, 4021, 1070, 1765, 1322,   26,  548, 1525,
77, 2181, 2752,  127, 2147,  211,   41, 1575,  151,  479,  697,
1023, 1194,  462,  583,   37,  943,  996,  480, 1497,  717,  224,
219, 1531,  498,   44,  288,  267,  600,   52,  269, 1086,  386,
774,  509,    8,  197,  136,   12, 1124,   64,  380,  811,  232,
192,  731,  715,  226,  605,  539, 1491,  323,  240,  179,  702,
156,   82, 1397,  354,  778,  603, 1001,  385,  986,  203,  149,
3260, 1025,   31,  100, 2055, 4043,   79,  238, 3931, 2351,  595,
110,  215,    0,  563,  206,  660,  242,  577,  179,  157,  192,
1582, 1044,  378, 1687, 2915,  280,  765, 2819,  511, 1521,  745,
2491,  580, 2072, 6450,  578,  745, 1075, 1103, 1549, 1520,  138,
420,   87,   71,  814,  603, 1349,  162, 1027,  783,  326,  101,
876,  381,  905,  156,  419,  239,  119,  129,  467])
# Draw bootstrap replicates of the mean no-hitter time (equal to tau): bs_replicates
bs_replicates = draw_bs_reps(nohitter_times, np.mean, 10000)
# Compute the 95% confidence interval: conf_int
conf_int = np.percentile(nohitter_times, [2.5, 97.5])
# Print the confidence interval
print('95% confidence interval =', conf_int, 'games')
# Plot the histogram of the replicates
_ = plt.hist(bs_replicates, bins = 50, dnesity = True)
_ = plt.xlabel(r'$\tau$ (games)')
_ = plt.ylabel('PDF')
# Show the plot
plt.show()
plt.clf()
# Draw bootstrap replicates of the mean no-hitter time (equal to tau): bs_replicates
bs_replicates = draw_bs_reps(nohitter_times, np.mean, 10000)
# Compute the 95% confidence interval: conf_int
conf_int = np.percentile(bs_replicates, [2.5, 97.5])
# Print the confidence interval
print('95% confidence interval =', conf_int, 'games')
# Plot the histogram of the replicates
_ = plt.hist(bs_replicates, bins = 50, dnesity = True)
_ = plt.xlabel(r'$\tau$ (games)')
_ = plt.ylabel('PDF')
# Show the plot
plt.show()
plt.clf()
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import pandas as pd
# Set default Seaborn style
sns.set()
light = pd.read_csv("/home/cla/Documentos/Vitor/DataCamp/Data-Scientist-with-Python/Datasets/speed-of-light.csv")
michelson_speed_of_light = np.array(light['velocity of light in air (km/s)'])
election = pd.read_csv("/home/cla/Documentos/Vitor/DataCamp/Data-Scientist-with-Python/Datasets/2008_election_results_swing.csv")
election['total'] = election.total_votes/900
female_literacy_fertility = pd.read_csv("/home/cla/Documentos/Vitor/DataCamp/Data-Scientist-with-Python/Datasets/female_literacy_fertility.csv")
female_literacy_fertility = female_literacy_fertility[(female_literacy_fertility['fertility'] > 1000)]
illiteracy = 100 - np.array(female_literacy_fertility['female literacy'])
fertility = np.array(female_literacy_fertility['fertility'])/1000
election['total'] = election.total_votes/900
anscombe = pd.read_csv("/home/cla/Documentos/Vitor/DataCamp/Data-Scientist-with-Python/Datasets/anscombe.csv")
def ecdf(data):
"""Compute ECDF for a one-dimensional array of measurements."""
# Number of data points: n
n = len(data)
# x-data for the ECDF: x
x = np.sort(data)
# y-data for the ECDF: y
y = np.arange(1, n + 1) / n
return x, y
nohitter_times = np.array([ 843, 1613, 1101,  215,  684,  814,  278,  324,  161,  219,  545,
715,  966,  624,   29,  450,  107,   20,   91, 1325,  124, 1468,
104, 1309,  429,   62, 1878, 1104,  123,  251,   93,  188,  983,
166,   96,  702,   23,  524,   26,  299,   59,   39,   12,    2,
308, 1114,  813,  887,  645, 2088,   42, 2090,   11,  886, 1665,
1084, 2900, 2432,  750, 4021, 1070, 1765, 1322,   26,  548, 1525,
77, 2181, 2752,  127, 2147,  211,   41, 1575,  151,  479,  697,
557, 2267,  542,  392,   73,  603,  233,  255,  528,  397, 1529,
1023, 1194,  462,  583,   37,  943,  996,  480, 1497,  717,  224,
219, 1531,  498,   44,  288,  267,  600,   52,  269, 1086,  386,
176, 2199,  216,   54,  675, 1243,  463,  650,  171,  327,  110,
774,  509,    8,  197,  136,   12, 1124,   64,  380,  811,  232,
192,  731,  715,  226,  605,  539, 1491,  323,  240,  179,  702,
156,   82, 1397,  354,  778,  603, 1001,  385,  986,  203,  149,
576,  445,  180, 1403,  252,  675, 1351, 2983, 1568,   45,  899,
3260, 1025,   31,  100, 2055, 4043,   79,  238, 3931, 2351,  595,
110,  215,    0,  563,  206,  660,  242,  577,  179,  157,  192,
192, 1848,  792, 1693,   55,  388,  225, 1134, 1172, 1555,   31,
1582, 1044,  378, 1687, 2915,  280,  765, 2819,  511, 1521,  745,
2491,  580, 2072, 6450,  578,  745, 1075, 1103, 1549, 1520,  138,
1202,  296,  277,  351,  391,  950,  459,   62, 1056, 1128,  139,
420,   87,   71,  814,  603, 1349,  162, 1027,  783,  326,  101,
876,  381,  905,  156,  419,  239,  119,  129,  467])
mean = np.mean(michelson_speed_of_light)
std = np.std(michelson_speed_of_light)
samples = np.random.normal(mean, std, 10000)
# Create a Figure and an Axes with plt.subplots
fig, ax = plt.subplots()
fig.tight_layout(pad = 5)
sns.distplot(michelson_speed_of_light, hist = True, kde = True,
bins = 9, color = 'darkblue',
hist_kws = {'edgecolor':'black'},
kde_kws = {'linewidth': 4})
#_ = ax.hist(michelson_speed_of_light, bins =  9, density = True)
#_ = ax.hist(samples, bins =  int(180/5), density = True, histtype = 'step')
_ = ax.set_xlabel('speed of light(km/s)')
_ = ax.set_ylabel('PDF')
plt.show()
x_vel_light, y_vel_light = ecdf(michelson_speed_of_light)
x_vel_light_sample, y_vel_light_sample = ecdf(samples)
# Create a Figure and an Axes with plt.subplots
fig, ax = plt.subplots()
fig.tight_layout(pad = 5)
_ = ax.plot(x_vel_light, y_vel_light, marker = '.', linestyle = 'none')
_ = ax.plot(x_vel_light_sample, y_vel_light_sample)
_ = ax.set_xlabel('speed of light (km/s)')
_ = ax.set_ylabel('CDF')
plt.show()
x_vel_light, y_vel_light = ecdf(michelson_speed_of_light)
x_vel_light_sample, y_vel_light_sample = ecdf(samples)
# Create a Figure and an Axes with plt.subplots
fig, ax = plt.subplots()
fig.tight_layout(pad = 5)
_ = ax.plot(x_vel_light, y_vel_light, marker = '.', linestyle = 'none')
_ = ax.plot(x_vel_light_sample, y_vel_light_sample)
_ = ax.set_xlabel('speed of light (km/s)')
_ = ax.set_ylabel('CDF')
plt.show()
mean = np.mean(michelson_speed_of_light)
std = np.std(michelson_speed_of_light)
np.random.seed(42)
samples = np.random.normal(mean, std + std/2, 10000)
x_vel_light_sample, y_vel_light_sample = ecdf(samples)
# Create a Figure and an Axes with plt.subplots
fig, ax = plt.subplots()
fig.tight_layout(pad = 5)
_ = ax.plot(x_vel_light, y_vel_light, marker = '.', linestyle = 'none')
_ = ax.plot(x_vel_light_sample, y_vel_light_sample)
_ = ax.set_xlabel('speed of light (km/s)')
_ = ax.set_ylabel('CDF')
plt.show()
mean = np.mean(michelson_speed_of_light)
std = np.std(michelson_speed_of_light)
np.random.seed(42)
samples = np.random.normal((mean + mean*0.0001), std, 10000)
x_vel_light_sample, y_vel_light_sample = ecdf(samples)
# Create a Figure and an Axes with plt.subplots
fig, ax = plt.subplots()
fig.tight_layout(pad = 5)
_ = ax.plot(x_vel_light, y_vel_light, marker = '.', linestyle = 'none')
_ = ax.plot(x_vel_light_sample, y_vel_light_sample)
_ = ax.set_xlabel('speed of light (km/s)')
_ = ax.set_ylabel('CDF')
plt.show()
mean = np.mean(michelson_speed_of_light)
std = np.std(michelson_speed_of_light)
np.random.seed(42)
samples = np.random.normal((mean + mean*0.0001), std, 10000)
x_vel_light_sample, y_vel_light_sample = ecdf(samples)
# Create a Figure and an Axes with plt.subplots
fig, ax = plt.subplots()
fig.tight_layout(pad = 5)
_ = ax.plot(x_vel_light, y_vel_light, marker = '.', linestyle = 'none')
_ = ax.plot(x_vel_light_sample, y_vel_light_sample)
_ = ax.set_xlabel('speed of light (km/s)')
_ = ax.set_ylabel('CDF')
_ = ax.annotate("CDF for 'optimal' \nparamenters of a \nbad model", xy = ((mean + mean*0.0001)+10, 0.6), xytext = (300000.38524000003, 0.3), arrowprops = {'arrowstyle': '->', 'color': 'gray'})
plt.show()
plt.clf()
plt.clf()
# Seed random number generator
np.random.seed(42)
# Compute mean no-hitter time: tau
tau = np.mean(nohitter_times)
# Draw out of an exponential distribution with parameter tau: inter_nohitter_time
inter_nohitter_time = np.random.exponential(tau, 100000)
# Plot the PDF and label axes
_ = plt.hist(inter_nohitter_time, density = True,
bins = 50, histtype = 'step')
_ = plt.xlabel('Games between no-hitters')
_ = plt.ylabel('PDF')
# Show the plot
plt.show()
plt.clf()
# Create an ECDF from real data: x, y
x, y = ecdf(nohitter_times)
# Create a CDF from theoretical samples: x_theor, y_theor
x_theor, y_theor = ecdf(inter_nohitter_time)
# Overlay the plots
_ = plt.plot(x_theor, y_theor)
_ = plt.plot(x, y, marker = '.', linestyle = 'none')
# Margins and axis labels
_ = plt.margins(0.02)
_ = plt.xlabel('Games between no-hitters')
_ = plt.ylabel('CDF')
# Show the plot
plt.show()
plt.clf()
np.random.seed(42)
# Plot the theoretical CDFs
_ = plt.plot(x_theor, y_theor)
_ = plt.plot(x, y, marker='.', linestyle='none')
_ = plt.margins(0.02)
_ = plt.xlabel('Games between no-hitters')
_ = plt.ylabel('CDF')
# Take samples with half tau: samples_half
samples_half = np.random.exponential(tau/2, 10000)
# Take samples with double tau: samples_double
samples_double = np.random.exponential(tau*2, 10000)
# Generate CDFs from these samples
x_half, y_half = ecdf(samples_half)
x_double, y_double = ecdf(samples_double)
# Plot these CDFs as lines
_ = plt.plot(x_half, y_half)
_ = plt.plot(x_double, y_double)
# Show the plot
plt.show()
plt.clf()
# Create a Figure and an Axes with plt.subplots
fig, ax = plt.subplots()
fig.tight_layout(pad = 5)
_ = ax.plot(election.total_votes/900, election.dem_share, marker = '.', linestyle = 'none')
_ = ax.set_xlabel('total votes (thousands)')
_ = ax.set_ylabel('percent of vote for Obama')
_ = ax.set_ylim(0, 100)
_ = ax.set_xlim(0, 1000)
plt.show()
plt.clf()
a, b = np.polyfit(election.total_votes, election.dem_share, 1)
x = np.array([0, 1000])
y = a * x*900 + b
g = sns.relplot(x = 'total',
y = 'dem_share',
data = election,
kind = 'scatter',
height = 2.6)
_ = g.set(xlabel = 'total votes (thousands)',
ylabel = 'percent of vote for Obama',
ylim = (0, 100),
xlim = (0, 1000))
_ = plt.plot(x, y)
plt.show()
plt.clf()
a, b = np.polyfit(election.total_votes, election.dem_share, 1)
x = np.array([0, 1000])
y = a * x*900 + b
g = sns.relplot(x = 'total',
y = 'dem_share',
data = election,
kind = 'scatter',
height = 2.6)
_ = g.set(xlabel = 'total votes (thousands)',
ylabel = 'percent of vote for Obama',
ylim = (0, 100),
xlim = (0, 1000))
_ = plt.plot(x, y)
plt.show()
plt.clf()
np.arange(7)
election = pd.read_csv("/home/cla/Documentos/Vitor/DataCamp/Data-Scientist-with-Python/Datasets/2008_election_results_swing.csv")
election['total'] = election.total_votes/900
election['total'] = election.total_votes.values/900
election['total']
election.total_votes.values
election.total_votes.values/900
election['total'] = election.total_votes.values/900
election['total']
total = election.total_votes.values/900
total
dem_share = election.dem_share.values
dem_share
bs_dem_share = dem_share[bs_inds]
inds = np.arange(len(total))
bs_inds = np.random.choice(inds, len(inds))
bs_total_votes = total[bs_inds]
bs_dem_share = dem_share[bs_inds]
np.polyfit(total, dem_share, 1)
bs_slope, bs_intercept = np.polytfit(bs_total_votes, bs_dem_share, 1)
bs_slope, bs_intercept
bs_slope, bs_intercept
bs_slope, bs_intercept = np.polytfit(bs_total_votes, bs_dem_share, 1)
bs_slope, bs_intercept = np.polyfit(bs_total_votes, bs_dem_share, 1)
bs_slope, bs_intercept
def draw_bs_pairs_linreg(x, y, size=1):
"""Perform pairs bootstrap for linear regression."""
# Set up array of indices to sample from: inds
inds = np.arange(len(x))
# Initialize replicates: bs_slope_reps, bs_intercept_reps
bs_slope_reps = np.empty(size)
bs_intercept_reps = np.empty(size)
# Generate replicates
for i in range(size):
bs_inds = np.random.choice(inds, size = len(inds))
bs_x, bs_y = x[bs_inds], y[bs_inds]
bs_slope_reps[i], bs_intercept_reps[i] = np.polyfit(bs_x, bs_y, 1)
return bs_slope_reps, bs_intercept_reps
def draw_bs_pairs_linreg(x, y, size=1):
"""Perform pairs bootstrap for linear regression."""
# Set up array of indices to sample from: inds
inds = np.arange(len(x))
# Initialize replicates: bs_slope_reps, bs_intercept_reps
bs_slope_reps = np.empty(size)
bs_intercept_reps = np.empty(size)
# Generate replicates
for i in range(size):
bs_inds = np.random.choice(inds, size = len(inds))
bs_x, bs_y = x[bs_inds], y[bs_inds]
bs_slope_reps[i], bs_intercept_reps[i] = np.polyfit(bs_x, bs_y, 1)
return bs_slope_reps, bs_intercept_reps
female_literacy_fertility = pd.read_csv("/home/cla/Documentos/Vitor/DataCamp/Data-Scientist-with-Python/Datasets/female_literacy_fertility.csv")
female_literacy_fertility = female_literacy_fertility[(female_literacy_fertility['fertility'] > 1000)]
illiteracy = 100 - np.array(female_literacy_fertility['female literacy'])
fertility = np.array(female_literacy_fertility['fertility'])/1000
# Generate replicates of slope and intercept using pairs bootstrap
bs_slope_reps, bs_intercept_reps = draw_bs_pairs_linreg(illiteracy, fertility, 1000)
# Compute and print 95% CI for slope
print(np.percentile(bs_slope_reps, [2.5, 97.5]))
# Plot the histogram
_ = plt.hist(bs_slope_reps, bins = 50, density = True)
_ = plt.xlabel('slope')
_ = plt.ylabel('PDF')
plt.show()
plt.clf()
x = np.array([0, 100])
x
# Generate array of x-values for bootstrap lines: x
x = np.array([0, 100])
# Plot the bootstrap lines
for i in range(100):
_ = plt.plot(x,
bs_slope_reps[i]*x + bs_intercept_reps[i],
linewidth = 0.5, alpha = 0.2, color = 'red')
# Plot the data
_ = plt.plot(illiteracy, fertility, marker = '.', linestyle = 'none')
# Label axes, set the margins, and show the plot
_ = plt.xlabel('illiteracy')
_ = plt.ylabel('fertility')
plt.margins(0.02)
plt.show()
plt.clf()
x = np.array([0, max(total)])
x
def draw_bs_pairs_linreg(x, y, size=1):
"""Perform pairs bootstrap for linear regression."""
# Set up array of indices to sample from: inds
inds = np.arange(len(x))
# Initialize replicates: bs_slope_reps, bs_intercept_reps
bs_slope_reps = np.empty(size)
bs_intercept_reps = np.empty(size)
# Generate replicates
for i in range(size):
bs_inds = np.random.choice(inds, size = len(inds))
bs_x, bs_y = x[bs_inds], y[bs_inds]
bs_slope_reps[i], bs_intercept_reps[i] = np.polyfit(bs_x, bs_y, 1)
return bs_slope_reps, bs_intercept_reps
# Generate replicates of slope and intercept using pairs bootstrap
bs_slope_reps, bs_intercept_reps = draw_bs_pairs_linreg(total, dem_share, 1000)
# Generate array of x-values for bootstrap lines: x
x = np.array([0, max(total)])
# Plot the bootstrap lines
for i in range(100):
_ = plt.plot(x,
bs_slope_reps[i]*x + bs_intercept_reps[i],
linewidth = 0.5, alpha = 0.2, color = 'red')
# Plot the data
_ = plt.plot(total, dem_share, marker = '.', linestyle = 'none')
# Label axes, set the margins, and show the plot
_ = plt.xlabel('total votes (thousands)')
_ = plt.ylabel('percent of vote for Obama')
plt.margins(0.02)
plt.show()
plt.clf()
reticulate::repl_python()
import matplotlib.pyplot as plt
reticulate::repl_python()
reticulate::repl_python()
def plot_ecdf(x_val, y_val, x_label, y_label):
reticulate::repl_python()
reticulate::repl_python()
